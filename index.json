[{"authors":["Shadaj Laddad","Conor Power","Mae Milano","Alvin Cheung","Joseph M. Hellerstein"],"categories":null,"content":"","date":1672905600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1673142553,"objectID":"c205756e8652a2658239d3df559b4e2f","permalink":"http://languagesforsyste.ms/publication/keep-calm-and-crdt-on/","publishdate":"2023-01-05T00:00:00-08:00","relpermalink":"/publication/keep-calm-and-crdt-on/","section":"publication","summary":"Despite decades of research and practical experience, developers have few tools for programming reliable distributed applications without resorting to expensive coordination techniques. Conflict-free replicated datatypes (CRDTs) are a promising line of work that enable coordination-free replication and offer certain eventual consistency guarantees in a relatively simple object-oriented API. Yet CRDT guarantees extend only to data updates; observations of CRDT state are unconstrained and unsafe. We propose an agenda that embraces the simplicity of CRDTs, but provides richer, more uniform guarantees. We extend CRDTs with a query model that reasons about which queries are safe without coordination by applying monotonicity results from the CALM Theorem, and lay out a larger agenda for developing CRDT data stores that let developers safely and efficiently interact with replicated application state.","tags":null,"title":"Keep CALM and CRDT On","type":"publication"},{"authors":["Mae Milano"],"categories":null,"content":"","date":1671523200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1671523200,"objectID":"84bdbd7e91b06290a7252e4d2dd2458f","permalink":"http://languagesforsyste.ms/talk/researching-with-undergraduates/","publishdate":"2022-12-20T00:00:00-08:00","relpermalink":"/talk/researching-with-undergraduates/","section":"talk","summary":"In this talk, I use the metaphor of a university course (and its syllabus) to motivate aspects of effective mentorship. In particular, we’ll focus on selecting projects for undergraduate research, on-boarding research assistants, and helping your undergraduates maintain focus and motivation throughout the semester.","tags":["teaching"],"title":"Researching with Undergraduates: a Curricular Approach","type":"talk"},{"authors":["Shadaj Laddad","Conor Power","Mae Milano","Alvin Cheung","Joseph M. Hellerstein"],"categories":null,"content":"","date":1664607600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"7ff23cf7228e5dd011c43fb11fb4e667","permalink":"http://languagesforsyste.ms/publication/katara/","publishdate":"2022-10-01T00:00:00-07:00","relpermalink":"/publication/katara/","section":"publication","summary":"Conflict-free replicated data types (CRDTs) are a promising tool for designing scalable, coordination-free distributed systems. However, constructing correct CRDTs is difficult, posing a challenge for even seasoned developers. As a result, CRDT development is still largely the domain of academics, with new designs often awaiting peer review and a manual proof of correctness. In this paper, we present Katara, a program synthesis-based system that takes sequential data type implementations and automatically synthesizes verified CRDT designs from them. Key to this process is a new formal definition of CRDT correctness that combines a reference sequential type with a lightweight ordering constraint that resolves conflicts between noncommutative operations. Our process follows the tradition of work in verified lifting, including an encoding of correctness into SMT logic using synthesized inductive invariants and hand-crafted grammars for the CRDT state and runtime. Katara is able to automatically synthesize CRDTs for a wide variety of scenarios, from reproducing classic CRDTs to synthesizing novel designs based on specifications in existing literature. Crucially, our synthesized CRDTs are fully, automatically verified, eliminating entire classes of common errors and reducing the process of producing a new CRDT from a painstaking paper proof of correctness to a lightweight specification.","tags":null,"title":"Katara: Synthesizing CRDTs with Verified Lifting","type":"publication"},{"authors":["Mae Milano","Joshua Turcotti"],"categories":null,"content":"","date":1655708400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"0dc24f0098ff78b3a3ed1362a006661f","permalink":"http://languagesforsyste.ms/talk/fearless-apple/","publishdate":"2022-06-20T00:00:00-07:00","relpermalink":"/talk/fearless-apple/","section":"talk","summary":"This talk presents a user-centric overview of a new type system for concurrent programs, allowing threads to exchange complex, arbitrarily connected object graphs without risking destructive data races. While this goal is shared by a rich history of past work, existing solutions either rely on strictly enforced heap invariants that prohibit natural programming patterns or demand pervasive annotations that bring formidable formal overhead to the simplest programming tasks. As a result, past systems cannot express intuitively simple code without surprising and unnatural rewrites. Our work avoids these pitfalls through a novel type system that provides sound reasoning about separation in the heap while remaining amenable to whatever style of heap manipulations the programmer desires. This sweet spot is attained by tracking an invariant as strong as prior work, but allowing arbitrary violations to arise and persist across the program until recovery is needed. We present this system with large code examples demonstrating natural expression of patterns prior work balks at, a formal proof of correctness—that well-typed programs cannot encounter destructive data races at run time—and an efficient type checker implemented in Gallina and Ocaml.","tags":[],"title":"A developer-centric approach to Fearless Concurrency","type":"talk"},{"authors":["Mae Milano"],"categories":null,"content":"","date":1655708400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"4b37ac588a61d7507b8c58c348402d9b","permalink":"http://languagesforsyste.ms/talk/fearless-pldi/","publishdate":"2022-06-20T00:00:00-07:00","relpermalink":"/talk/fearless-pldi/","section":"talk","summary":"This talk proposes a new type system for concurrent programs, allowing threads to exchange complex, arbitrarily connected object graphs without risking destructive data races. While this goal is shared by a rich history of past work, existing solutions either rely on strictly enforced heap invariants that prohibit natural programming patterns or demand pervasive annotations that bring formidable formal overhead to the simplest programming tasks. As a result, past systems cannot express intuitively simple code without surprising and unnatural rewrites. Our work avoids these pitfalls through a novel type system that provides sound reasoning about separation in the heap while remaining amenable to whatever style of heap manipulations the programmer desires. This sweet spot is attained by tracking an invariant as strong as prior work, but allowing arbitrary violations to arise and persist across the program until recovery is needed. We present this system with large code examples demonstrating natural expression of patterns prior work balks at, a formal proof of correctness—that well-typed programs cannot encounter destructive data races at run time—and an efficient type checker implemented in Gallina and Ocaml.","tags":[],"title":"Fearless Concurrency PLDI Talk","type":"talk"},{"authors":null,"categories":null,"content":"More details can be found in the PLDI paper.\n","date":1655683200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"d4a7c18c63a054537efde28b52133371","permalink":"http://languagesforsyste.ms/project/fearless-concurrency/","publishdate":"2022-06-20T00:00:00Z","relpermalink":"/project/fearless-concurrency/","section":"project","summary":"We're building new languages for safely programming with shared mutable objects.  In our work, threads can freely exchange mutable objects and manipulate state concurrently---with no possibility of a destructive data race.","tags":["Linear Types","Ownership","Programming Languages","Concurrency"],"title":"Bringing Fearless Concurrency to the Masses","type":"project"},{"authors":null,"categories":null,"content":"Please visit the main Hydro website to learn more!\n","date":1655683200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"c5f32a66c01d23d83af3595c60391480","permalink":"http://languagesforsyste.ms/project/hydro/","publishdate":"2022-06-20T00:00:00Z","relpermalink":"/project/hydro/","section":"project","summary":"The Hydro Project at UC Berkeley is developing cloud-native programming models that allow anyone to develop scalable and reslilient distributed applications that take full advantage of the elasticity of cloud infrastructure. Our research spans across databases, distributed systems, and programming languages to deliver a modern, end-to-end stack for cloud programming.","tags":["Programming Languages","Distributed Systems"],"title":"Hydro: Software that Runs at Every Scale","type":"project"},{"authors":["Mae Milano","Joshua Turcotti","Andrew Myers"],"categories":null,"content":"","date":1654758000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"ccbfdee6a95b2dd6168fb7f027a70802","permalink":"http://languagesforsyste.ms/publication/fearless-concurrency/","publishdate":"2022-06-09T00:00:00-07:00","relpermalink":"/publication/fearless-concurrency/","section":"publication","summary":"This paper proposes a new type system for concurrent programs, allowing threads to exchange complex object graphs without risking destructive data races. While this goal is shared by a rich history of past work, existing solutions either rely on strictly enforced heap invariants that prohibit natural programming patterns or demand pervasive annotations even for simple programming tasks. As a result, past systems cannot express intuitively simple code without unnatural rewrites or substantial annotation burdens. Our work avoids these pitfalls through a novel type system that provides sound reasoning about separation in the heap while remaining flexible enough to support a wide range of desirable heap manipulations. This new sweet spot is attained by enforcing a heap domination invariant similarly to prior work, but tempering it by allowing complex exceptions that add little annotation burden. Our results include: (1) code examples showing that common data structure manipulations which are difficult or impossible to express in prior work are natural and direct in our system, (2) a formal proof of correctness demonstrating that well-typed programs cannot encounter destructive data races at run time, and (3) an efficient type checker implemented in Gallina and OCaml.","tags":null,"title":"A flexible type system for fearless concurrency","type":"publication"},{"authors":["Alvin Cheung","Natacha Crooks","Joseph M. Hellerstein","Mae Milano"],"categories":null,"content":"","date":1610524800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669155353,"objectID":"cb63e4de1cecf2185844c32222f70a26","permalink":"http://languagesforsyste.ms/publication/pact/","publishdate":"2021-01-13T00:00:00-08:00","relpermalink":"/publication/pact/","section":"publication","summary":"Nearly twenty years after the launch of AWS, it remains difficult for most developers to harness the enormous potential of the cloud. In this paper we lay out an agenda for a new generation of cloud programming research aimed at bringing research ideas to programmers in an evolutionary fashion. Key to our approach is a separation of distributed programs into a PACT of four facets: Program semantics, Availablity, Consistency and Targets of optimization. We propose to migrate developers gradually to PACT programming by lifting familiar code into our more declarative level of abstraction. We then propose a multi-stage compiler that emits humanreadable code at each stage that can be hand-tuned by developers seeking more control. Our agenda raises numerous research challenges across multiple areas including language design, query optimization, transactions, distributed consistency, compilers and program synthesis.","tags":null,"title":"New Directions in Cloud Programming","type":"publication"},{"authors":["Mae Milano"],"categories":null,"content":" After many years at Cornell University, I have finally completed my PhD journey! My dissertation, entitled \u0026ldquo;Programming Safely with Weak (And Strong) Consistency\u0026rdquo;, is now available via ProQuest (or directly from me).\nThat document is 364 pages, is there a summary? Sure! The unifying theme of my dissertation is that writing programs against weak consistency is inherently difficult. My dissertation makes the job of writing safe programs against weak consistency easier, by introducing programming languages in which strong guarantees are defended from weakly-consistent influence, and in which programmers can write consistent-by-construction programs atop underlying weakly-consistent replication.\nThe first of these languages is MixT, a new language for writing mixed-consistency transactions. These atomic transactions can operate against data at multiple consistency levels simultaneously, and are equipped with an information-flow type system which guarantees weakly-consistent observations cannot influence strongly-consistent actions.\nWhile mixed-consistency transactions can defend strong data from weak observations, they cannot ensure that fully-weak code is itself correct. To address this, we leverage monotonic data types to introduce a core language of datalog-like predicates and triggers. In this language, programmers can write monotonic functions over a set of monotonic shared objects, ultimately resulting in a boolean. These monotonic, boolean-returning functions are stable predicates: once they have become true, they remain true for all time. Actions which are predicated on these stable predicates cannot be invalidated by missed or future updates.\nThis monotonic language sits at the core of Derecho, a new system for building strongly-consistent distributed systems via replicated state machines. Derecho\u0026rsquo;s Shared State Table (SST) implements monotonic datatypes atop Remote Direct Memory Access (RDMA), resulting in a high-performance, asynchronous substrate on which to build Derecho\u0026rsquo;s monotonic language. Using this SST, we have rephrased the Paxos delivery condition monotonically, granting strong consistency despite the underlying asynchronous replication.\nFinally Gallifrey exposes the monotonic reasoning properties of Derecho\u0026rsquo;s core language directly to the user, safely integrating monotonic datatypes into a traditional Java-like programming language. Gallifrey allows any object to be asynchronously replicated via Restrictions to its interface, allowing only those operations which are safe to call concurrently. Datatypes shared under these restrictions can be viewed monotonically, using a language of predicates and triggers similar to that at the core of Derecho. A novel linear region-based type system enforces that shared object restrictions are respected.\nA PhD Takes a Village And mine is no exception. The kindness and generosity of the people who have surrounded me during my PhD never ceases to amaze. Without the community surrounding me, attaining a PhD would be nearly impossible. While my research and academic life has been touched by innumerable hands, I would like to specifically highlight the enormous assistance I have received from Andrew Myers, Ken Birman, Fabian Muehlboeck, Patrick LaFontaine and Danny Yang. It is no exaggeration to say that without their help and guiding presence, I could never have completed this PhD.\nTo everyone who has helped me on this journey: thank you. Sincerely, thank you.\n~Mae\n","date":1604127600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"9e21417e914bc2e20f71609bc915000b","permalink":"http://languagesforsyste.ms/post/dissertation/","publishdate":"2020-10-31T00:00:00-07:00","relpermalink":"/post/dissertation/","section":"post","summary":"My dissertation is now available [here](/files/thesis.pdf)","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"My Dissertation is Now Available!","type":"post"},{"authors":["Ken Birman","Mae Milano","Edward Tremel"],"categories":null,"content":"","date":1572159600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"424ba4874ff28ab4594897d7bff05834","permalink":"http://languagesforsyste.ms/talk/derecho-tutorial/","publishdate":"2019-10-27T00:00:00-07:00","relpermalink":"/talk/derecho-tutorial/","section":"talk","summary":"Cloud computing services often replicate data and require that data stays consistent.  This tutorial centers on Derecho, a library to assist with solving these problems [1, 2].  Derecho provides consistent replication with blazing speed, often outperforming the weakly-consistent mechanisms that dominate today's cloud computing infrastructures.  Derecho's asynchronous design is key to its performance: the system achieves lock-free data streaming for critical paths, and data movement is out-of-band from the control plane.  \n\n For this tutorial, our first goal is to understand the \"design pattern\" that enables this big performance boost: separating the control and data planes, performing updates on a code path distinct from that used for queries, and transforming the system to use an asynchronous streaming communication model. \n\n The tutorial is structured into two parts.  In the first half, based primarily on our TOCS paper [1], situates Derecho relative to prior work, explains how it obtains such high speeds, and reviews experiments that clarify why it outperforms prior solutions.  We also learn about features aimed at Edge IoT applications that work with real-time sensor data yet still need strong consistency.  The second part teaches attendees to use Derecho: we walk through the process of downloading the library, building services that use it, running them locally, and installing them on a cloud.  At the end of the second part, participants modify the Derecho demo (a simple AI Sys application), rebuild it and rerun it.  SOSP participants who only want to hear about the work but not to really learn the system are welcome to drop in just at the beginning, and then can duck out when we get to the hands-on stage.  \n[1] Derecho: Fast State Machine Replication for Cloud Services. S Jha, J Behrens, T Gkountouvas, M Milano, W Song, E Tremel, R Van Renesse, S Zink, and K Birman. ACM TOCS, 36 :2, April 2019.  \n[2] RDMC: A Reliable Multicast for Large Objects. Jonathan Behrens, Sagar Jha, Ken Birman, Edward Tremel.  IEEE DSN '18, Luxembourg, June 2018.","tags":[],"title":"Derecho Tutorial","type":"talk"},{"authors":["Weijia Song","Mae Milano","Sagar Jha","Edward Tremel","Xinzhe Yang","Ken Birman"],"categories":null,"content":"","date":1572159600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"45d0980e2fcffab29fae3a53e6768216","permalink":"http://languagesforsyste.ms/talk/derecho-poster-aisys/","publishdate":"2019-10-27T00:00:00-07:00","relpermalink":"/talk/derecho-poster-aisys/","section":"talk","summary":"It's become clear that Internet of Things (or IoT) applications work best when backed up by best-in class machine learning techniques.  And between every IoT device and its machine-learning backend lies a cloud-based system.  The huge volumes of data generated by these IoT devices and used by these machine learning applications have stressed current systems to their breaking point.  To unlock the next stage of scaling, we are building an intelligent object store atop Derecho, our best-in class cloud computing toolkit.  Our solution leverages Derecho's RDMA-based design to introduce a zero-copy pipeline all the way from the edge to the core, all while enjoying Derecho's rich features like automated recovery, guaranteed consistency, and explicit time-indexed versioning.","tags":[],"title":"Derecho's Intelligent Object Store","type":"talk"},{"authors":["Mae Milano","Rolph Recto","Tom Magrino","Andrew Myers"],"categories":null,"content":"","date":1557990000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"fafdb875449d72d7f6205976c66070e3","permalink":"http://languagesforsyste.ms/publication/gallifrey/","publishdate":"2019-04-16T00:00:00-07:00","relpermalink":"/publication/gallifrey/","section":"publication","summary":"Programming efficient distributed, concurrent systems requires new abstractions that go beyond traditional sequential programming. But programmers already have trouble getting sequential code right, so simplicity is essential. The core problem is that low-latency, high-availability access to data requires replication of mutable state. Keeping replicas fully consistent is expensive, so the question is how to expose asynchronously replicated objects to programmers in a way that allows them to reason simply about their code.  We propose an answer to this question in our ongoing work designing a new language, Gallifrey, which provides orthogonal replication through _restrictions_ with _merge strategies_, _contingencies_ for conflicts arising from concurrency, and _branches_, a novel concurrency control construct inspired by version control, to contain provisional behavior.","tags":null,"title":"A Tour of Gallifrey, a Language for Geodistributed Programming","type":"publication"},{"authors":["Mae Milano"],"categories":null,"content":"","date":1557990000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"4a2157ec1ec5c7635d191c3a7a461ee7","permalink":"http://languagesforsyste.ms/talk/gallifrey-conference-talk/","publishdate":"2019-05-16T00:00:00-07:00","relpermalink":"/talk/gallifrey-conference-talk/","section":"talk","summary":"Programming efficient distributed, concurrent systems requires new abstractions that go beyond traditional sequential programming. But programmers already have trouble getting sequential code right, so simplicity is essential. The core problem is that low-latency, high-availability access to data requires replication of mutable state. Keeping replicas fully consistent is expensive, so the question is how to expose asynchronously replicated objects to programmers in a way that allows them to reason simply about their code. We propose an answer to this question in our ongoing work designing a new language, Gallifrey, which provides orthogonal replication through _restrictions_ with _merge strategies_, _contingencies_ for conflicts arising from concurrency, and _branches_, a novel concurrency control construct inspired by version control, to contain provisional behavior.","tags":[],"title":"Gallifrey SNAPL Talk","type":"talk"},{"authors":["Mae Milano"],"categories":null,"content":"","date":1557471600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"2a801413ce0ecb44208c7b355d683fc6","permalink":"http://languagesforsyste.ms/talk/gallifrey-eglpls-talk/","publishdate":"2019-05-10T00:00:00-07:00","relpermalink":"/talk/gallifrey-eglpls-talk/","section":"talk","summary":"Programming efficient distributed, concurrent systems requires new abstractions that go beyond traditional sequential programming. But programmers already have trouble getting sequential code right, so simplicity is essential. The core problem is that low-latency, high-availability access to data requires replication of mutable state. Keeping replicas fully consistent is expensive, so the question is how to expose asynchronously replicated objects to programmers in a way that allows them to reason simply about their code. We propose an answer to this question in our ongoing work designing a new language, Gallifrey, which provides orthogonal replication through _restrictions_ with _merge strategies_, _contingencies_ for conflicts arising from concurrency, and _branches_, a novel concurrency control construct inspired by version control, to contain provisional behavior.","tags":[],"title":"Gallifrey EGLPLS Talk","type":"talk"},{"authors":["Sagar Jha","Jonathan Behrens","Theo Gkountouvas","Mae Milano","Weijia Song","Edward Tremel","Sydney Zink","Kenneth P. Birman","Robbert Van Renesse"],"categories":null,"content":"","date":1554102000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"f1cfa49bb62b2edc9e3e6412d4b99bb2","permalink":"http://languagesforsyste.ms/publication/derecho/","publishdate":"2019-04-01T00:00:00-07:00","relpermalink":"/publication/derecho/","section":"publication","summary":"Cloud computing services often replicate data and may require ways to coordinate distributed actions. Here we present Derecho, a library for such tasks. The API provides interfaces for structuring applications into patterns of subgroups and shards, supports state machine replication within them, and includes mechanisms that assist in restart after failures. Running over 100Gbps RDMA, Derecho can send millions of events per second in each subgroup or shard and throughput peaks at 16GB/s, substantially outperforming prior solutions. Configured to run purely on TCP, Derecho is still substantially faster than comparable widely used, highly-tuned, standard tools. The key insight is that on modern hardware (including non-RDMA networks), data-intensive protocols should be built from non-blocking data-flow components.","tags":null,"title":"Derecho: Fast State Machine Replication for Cloud Services","type":"publication"},{"authors":["Mae P. Milano","Andrew C. Myers"],"categories":null,"content":"","date":1542873600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"113968a6643b66a7aebfd94f7f07cfc2","permalink":"http://languagesforsyste.ms/publication/mixt-tr/","publishdate":"2018-11-22T00:00:00-08:00","relpermalink":"/publication/mixt-tr/","section":"publication","summary":"","tags":null,"title":"A Language for Mixing Consistency in Geodistributed Transactions: Technical Report","type":"publication"},{"authors":["Mae Milano"],"categories":null,"content":"","date":1529478000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"dd5bf8297dc4140f7f926f1a0e9582cd","permalink":"http://languagesforsyste.ms/talk/mixt/","publishdate":"2018-06-20T00:00:00-07:00","relpermalink":"/talk/mixt/","section":"talk","summary":"Programming concurrent, distributed systems is hard—especially when these systems mutate shared, persistent state replicated at geographic scale. To enable high availability and scalability, a new class of weakly consistent data stores has become popular. However, some data needs strong consistency. To manipulate both weakly and strongly consistent data in a single transaction, we introduce a new abstraction: mixed-consistency transactions, embodied in a new embedded language, MixT. Programmers explicitly associate consistency models with remote storage sites; each atomic, isolated transaction can access a mixture of data with different consistency models. Compile-time information-flow checking, applied to consistency models, ensures that these models are mixed safely and enables the compiler to automatically partition transactions into a single sub-transaction per consistency model. New run-time mechanisms ensure that consistency models can also be mixed safely, even when the data used by a transaction resides on separate, mutually unaware stores. Performance measurements show that despite their stronger guarantees, mixed-consistency transactions retain much of the speed of weak consistency, significantly outperforming traditional serializable transactions.","tags":[],"title":"MixT PLDI Talk","type":"talk"},{"authors":["Mae Milano"],"categories":null,"content":" It\u0026rsquo;s been a long wait. It was our great pleasure to present the MixT paper at this year\u0026rsquo;s PLDI, but we always felt that the conference version was missing a few details and extra explanations which (we sincerely hope) would go a long way towards explaining the MixT approach to distributed transactions. So it makes us overjoyed to finally make the extended Technical Report of the MixT paper available to the public.\nSo what\u0026rsquo;s this MixT thing all about, anyway? MixT is a domain-specific programming language for writing transactions, embedded into C++. What makes MixT unique is its approach to consistency and transaction isolation: rather than associate consistency with operations, MixT associates consistency with data and expects programmers to use multiple consistency models in the same application. With MixT:\n Transactions compile down to a sequence of standard, single-consistency transactions appropriate for execution on any number of SQL/NoSQL/NewSQL datastores.\n An information-flow type system keeps your consistent data safe from corruption by less-consistent data.\n You can use multiple consistency models even within a single transaction.\n A single transaction can execute across multiple independent datastores, while still preserving write atomicity.\n Transactions are expressive; you can define custom operations as methods, use while-loops and if-statements, and generally write code that looks and feels like the surrounding C++.\n   But the best explanation is the paper. What\u0026rsquo;s new for the TR? The technical report contains many details not previously seen in the MixT paper! You can expect to see extended rules for typing and translation, an all-new section featuring correctness arguments and read witnesses, and a loose formalization of how to lift isolation levels (in the database sense) to distributed consistency models. And more!\nYou can find it here Happy reading!\n","date":1529478000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"bedf3a24af564145ec1cd29436a018e2","permalink":"http://languagesforsyste.ms/post/mixt-tr/","publishdate":"2018-06-20T00:00:00-07:00","relpermalink":"/post/mixt-tr/","section":"post","summary":"Presenting MixT, our language for sanely mixing distinct consistency levels within a single transaction. Now in Tech Report form!","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Mixing Consistency with MixT: Technical Report Available!","type":"post"},{"authors":null,"categories":null,"content":" Stop me if you\u0026rsquo;ve heard this one before. You\u0026rsquo;re working on your phone or tablet, editing an online document, and you get on a plane. At first everything is fine; your edits are cached locally, and most of the application is local to your phone anyway. But then something happens; the page refreshes, or your device auto-connects to the dodgy in-flight wifi, and your previously-functioning application suddenly begins to \u0026hellip; not.\nDistributed programs need to accept disconnection. This common experience is a demonstration of an equally common flaw in modern client-facing distributed applications. Trouble is, it\u0026rsquo;s fundamentally hard to write a wide-area, heavily replicated distributed system\u0026mdash;leading many applications to opt for a weaker model, like an \u0026ldquo;interactive web page\u0026rdquo; where data can be \u0026ldquo;cached at the client\u0026rdquo; for quick responsiveness. But this model fundamentally isn\u0026rsquo;t reality. No matter what our frameworks tell us, distributed programs can\u0026rsquo;t use the same assumptions and metaphors as local concurrency or traditional websites. Modern distributed frameworks must accept that caches are replicas, that replicas are fundamental to good performance, and that replicas must tolerate periods of disconnection elegantly. It is key that a distributed program should never implicitly block, operating off of local replicas whenever possible.\nThis makes consistency hard. Because the moment you embrace the fact that your cached data is actually a first-class replica of shared global state, you must ask yourself how stale you can tolerate this data becoming, and what guarantees you need on the visibility of updates you make to this data. Existing replicated systems that handle disconnection well do quite badly at this, giving rise to bizarre errors on re-connection including the ever-present threat of losing the last few hours\u0026mdash;or even days\u0026mdash;of work. Correct applications must provide strong consistency by default, while ensuring any deviation from sequential consistency is locally justified and isolated from sensitive parts of the application.\nThese features need language support. There are a few (very few) applications today which can offer transparent replication without sacrificing consistency. But these applications are invariably hard to build, and prone to shipping subtle consistency bugs in production. The properties that we\u0026rsquo;re proposing\u0026mdash;non-blocking replication which tolerates disconnection while ensuring strong consistency by default\u0026mdash;are global properties of a distributed application. They can\u0026rsquo;t be enforced by a library alone, and they\u0026rsquo;re difficult enough that relying on \u0026ldquo;programmer discipline\u0026rdquo; has, repeatedly, been shown to be insufficient. These features can only be enforced at the language level\u0026mdash;which is where we come in.\nSo we\u0026rsquo;re building a new language. We\u0026rsquo;ve recently begun work on Gallifrey, a new programming language designed to address exactly these issues. Gallifrey enables per-task programming, where each thread can share any object with the world without sacrificing consistency. Gallifrey is based on Java with a minimum of changes, making it easy to pick up and intuitive to use.\nGallifrey\u0026rsquo;s core feature is enabled via author-provided Restrictions on objects\u0026rsquo; interfaces. When you want to share an object in Gallifrey, you must define a Restriction of its interface, limiting the available operations to only those which are safe to call concurrently and during disconnection. This Restriction, in effect, transforms your normal local object into a CRDT, a class of object which has a rich and well-studied semantics for guaranteeing convergence even in the face of weakly-consistent updates.\nTo keep the world of Restricted objects from consuming entire local programs, Gallifrey also employs a hybrid affine ownership type system which statically guarantees that an object (and everything it points to), when shared under a Restriction, can only be accessed via that Restriction. We\u0026rsquo;ve managed to take the best of affine typing (from languages like Rust) and apply it to Gallifrey, while still allowing a majority of Gallifrey code to enjoy the [almost] unrestricted aliasing and pervasive mutability common to Java programs.\nFinally we introduce branches, a new take on transactions inspired by the eponymous concept from version control. Opening a branch allows a program to create a new scope which is totally isolated from the rest of the world, in effect voluntarily disconnecting a portion of the program from the wider Gallifrey network. While within a branch, programmers can perform provisional operations which don\u0026rsquo;t guarantee sequential consistency, without worrying that these operations will threaten the consistency of the wider application.\nMore details can be found in the Gallifrey SNAPL paper.\n","date":1529452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586059318,"objectID":"548ccb2a05ff9091ff1d00590d1eca84","permalink":"http://languagesforsyste.ms/project/gallifrey/","publishdate":"2018-06-20T00:00:00Z","relpermalink":"/project/gallifrey/","section":"project","summary":"Gallifrey is a new programming language for distributed wide-area applications.  Gallifrey programs share state via replication, granting fast access to data without introducing mandatory synchronization points, all while maintaining sequential consistency by default.  Gallifrey aims to be easy-to-use, requiring a minimal annotation overhead atop an otherwise Java-like language.","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Gallifrey: a New Language for Distributed Programming","type":"project"},{"authors":null,"categories":null,"content":" Concurrency makes everything hard For many programmers, writing efficient concurrent datastructures is an exercise in scouring github and hoping that code quality and number of \u0026ldquo;stars\u0026rdquo; really do correlate. When it comes time to write your own concurrent datastructures, queue many sleepless nights spent worrying about whether this or that particular concurrency primitive is fast enough, or correct enough, to make the code work at the speeds you need. If there is any solace felt, it comes from the once-safe assumption of strong consistency; that, no matter how many races we might have missed, at least the result of the program will be some valid interleaving of concurrent threads.\nThis assumption is wrong. Because hardware isn\u0026rsquo;t as helpful as it once was. Modern processor and language memory models reduce the available consistency assumptions so much that it\u0026rsquo;s possible to read values which were never written, justify your own reads, and arbitrarily miss updates from concurrent threads. Simple patterns, like initializing an object and then handing it off directly to a newly-spawned thread, are simply not guaranteed to work.\nAnd distribution makes it harder. In a distributed setting, the costs of using stronger consistency models grow exponentially with the number of replicas in your system (essential for fault-tolerance) and the distance between these replicas (essential for global performance and availability). While there are a lot of good people doing excellent work to try and bring strongly-consistent shared data to a geo-distributed setting, the fundamentals are still not in our favor. And, far more urgently, major parts of the web have already moved to weaker consistency models.\nWe\u0026rsquo;re going to fix that. Or at least help. This project aims to bring the power of programming languages to bear on the world of weakly-consistent distributed programming. Our secret sauce is information flow, a key technology borrowed from the security literature and applied with new life here. Using information flow, it\u0026rsquo;s possible to ensure that weakly-consistent observations can never unduly influence strongly-consistent computations; it makes the points of crossover explicit, statically requiring that programmers upgrade the consistency of their observations when appropriate.\nThis technique is powerful; for more details, see our paper from PLDI 2018.\nAnd we\u0026rsquo;re not done yet. Our new project Gallifrey continues this legacy with a new programming language for the distributed world. Ready more at its project page!\n","date":1529452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572840039,"objectID":"9abcd3af79b104f0646fbc4376cf518d","permalink":"http://languagesforsyste.ms/project/languages-for-distribution/","publishdate":"2018-06-20T00:00:00Z","relpermalink":"/project/languages-for-distribution/","section":"project","summary":"Distributed Languages frequently either fail to capture replication, or insist in high-latency lockstep state machine replication.  Storage systems which avoid both pitfalls often do so by weakening consistency. We try to rein in weak consistency and capture replication and concurrency, all while constructively avoiding races and allowing safe, loosely-synchronized replication.","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Programming Replicated, Distributed Systems","type":"project"},{"authors":["Mae Milano","Andrew C. Myers"],"categories":null,"content":"","date":1527836400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"70c8ea9b0a628d469a99e2d3819fa718","permalink":"http://languagesforsyste.ms/publication/mixt/","publishdate":"2018-06-01T00:00:00-07:00","relpermalink":"/publication/mixt/","section":"publication","summary":"Programming concurrent, distributed systems is hard---especially when these systems mutate shared, persistent state replicated at geographic scale. To enable high availability and scalability, a new class of weakly consistent data stores has become popular. However, some data needs strong consistency. To manipulate both weakly and strongly consistent data in a single transaction, we introduce a new abstraction: mixed-consistency transactions, embodied in a new embedded language, MixT. Programmers explicitly associate consistency models with remote storage sites; each atomic, isolated transaction can access a mixture of data with different consistency models. Compile-time information-flow checking, applied to consistency models, ensures that these models are mixed safely and enables the compiler to automatically partition transactions. New run-time mechanisms ensure that consistency models can also be mixed safely, even when the data used by a transaction resides on separate, mutually unaware stores. Performance measurements show that despite their stronger guarantees, mixed-consistency transactions retain much of the speed of weak consistency, significantly outperforming traditional serializable transactions.","tags":null,"title":"MixT: A Language for Mixing Consistency in Geodistributed Transactions","type":"publication"},{"authors":["Sagar Jha","Jonathan Behrens","Theo Gkountouvas","Mae Milano","Weijia Song","Edward Tremel","Sydney Zink","Kenneth P. Birman","Robbert Van Renesse"],"categories":null,"content":"","date":1509519600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"3e62bf437b39d8b2fd35b76d913cfc66","permalink":"http://languagesforsyste.ms/publication/derecho-tr/","publishdate":"2017-11-01T00:00:00-07:00","relpermalink":"/publication/derecho-tr/","section":"publication","summary":"The coming generation of Internet-of-Things (IoT) applications will process massive amounts of incoming data while supporting data mining and online learning. In cases with demanding real-time requirements, such systems behave as smart memories: high-bandwidth services that capture sensor input, proceses it using machine-learning tools, replicate and store “interesting” data (discarding uninteresting content), update knowledge models, and trigger urgently-needed responses. Derecho is a high-throughput librry for building smart memories and similar services. At its core Derecho implements atomic multicast and state machine replication. Derecho’s replicated template defines a replicated type; the corresponding objects are associated with subgroups, which can be sharded into keyvalue structures. The persistent and volatile storage templates implement version vectors with optional NVM persistence. These support time-indexed access, offering lock-free snapshot isolation that blends temporal precision and causal consistency. Derecho automates application management, supporting multigroup structures and providing consistent knowledge of the current membership mapping. A query can access data from many shards or subgroups, and consistency is guaranteed without any form of distributed locking. Whereas many systems run consensus on the critical path, Derecho requires consensus only when updating membership. By leveraging an RDMA data plane and NVM storage, and adopting a novel receiver-side batching technique, Derecho can saturate a 12.5GB RDMA network, sending millions of events per second in each subgroup or shard. In a single subgroup with 2-16 members, throughput peaks at 16 GB/s for large (100MB or more) objects. When using version-vector storage, Derecho is limited by the speed of the SSD or RamDisk, showing no loss of performance as group sizes grow. While key-value subgroups would typically use 2 or 3-member shards, unsharded subgroups could be large. In tests with a 128-member group, Derecho’s multicast and Paxos protocols were just 2-3x slower than for a small group, depending on the traffic pattern. With network contention, slow members, or overlapping groups that generate concurrent traffic, Derecho’s protocols remain stable and adapt to the available bandwidth.","tags":null,"title":"Building Smart Memories and Cloud Services with Derecho","type":"publication"},{"authors":["Mae P. Milano","Andrew C. Myers"],"categories":null,"content":"","date":1475305200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"2f7527a392ce159e01ff4f958f69e4ce","permalink":"http://languagesforsyste.ms/publication/mm-16-tr/","publishdate":"2016-10-01T00:00:00-07:00","relpermalink":"/publication/mm-16-tr/","section":"publication","summary":"","tags":null,"title":"Mixing Consistency in Geodistributed Transactions: Technical Report (old)","type":"publication"},{"authors":["Nate Foster","Dexter Kozen","Mae Milano","Alexandra Silva","Laure Thompson"],"categories":null,"content":"","date":1435734000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"87bc941cff91d9e6bcea323d33b3d12a","permalink":"http://languagesforsyste.ms/publication/netkat/","publishdate":"2015-07-01T00:00:00-07:00","relpermalink":"/publication/netkat/","section":"publication","summary":"","tags":null,"title":"A Coalgebraic Decision Procedure for NetKAT","type":"publication"},{"authors":null,"categories":null,"content":" In-datacenter replication just got a lot faster. Derecho is a new framework for building replicated, fault-tolerant distributed systems within a datacenter. At its core, Derecho provides a best-in-class consistent multicast abstraction, sending multi-target messages at blazing speed and in lock-step. Derecho\u0026rsquo;s object-oriented programming layer makes it easy to build any distributed application straight from a standard, single-machine approach; individual classes are automatically replicated in user-specified configurations, and a straightforward, type-safe RPC mechanism allows easy communication between replica groups.\nDerecho realizes a major observation: that programming a distributed system with an eye towards protocol convergence (or strong eventual consistency) yields significant performance benefits by delaying consensus events for as long as possible. Derecho\u0026rsquo;s core protocols are written in a simple convergent programming language (watch this space), giving us constructive confidence that our protocols never diverge \u0026ndash; which avoids much of the proof (and correctness) burden of traditional distributed system design.\nThis project is a major collaboration between several groups at Cornell University; the group is expanding every day, but has so far included Sagar Jha, Jonathan Behrens, Theo Gkountouvas, Mae Milano, Weijia Song, Edward Tremel, Sydney Zink, Kenneth P. Birman, Robbert Van Renesse, and the students of CS4999. For more detail, you should check the project website or read about it on Ken Birman\u0026rsquo;s blog.\n","date":1433116800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"c8c99074cdb6b42a7de679e50da0c1b4","permalink":"http://languagesforsyste.ms/project/derecho/","publishdate":"2015-06-01T00:00:00Z","relpermalink":"/project/derecho/","section":"project","summary":"Derecho is a new framework for building replicated, fault-tolerant distributed systems within a datacenter.  It provides a best-in-class consistent multicast abstraction, and is easy to use via user-defined replicated objects and RPC.","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Derecho: Programming the Datacenter","type":"project"},{"authors":["Joe Gibbs Politz","Alejandro Martinez","Mae Milano","Sumner Warren","Daniel Patterson","Junsong Li","Anand Chitipothu","Shriram Krishnamurthi"],"categories":null,"content":"","date":1357027200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640973438,"objectID":"46a2253e7e38a5df8328b38638d550e6","permalink":"http://languagesforsyste.ms/publication/python/","publishdate":"2013-01-01T00:00:00-08:00","relpermalink":"/publication/python/","section":"publication","summary":"","tags":null,"title":"Python: The Full Monty","type":"publication"}]